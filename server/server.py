#!/usr/bin/env python
from fastapi import FastAPI, Response, HTTPException
import os
from openai import OpenAI
from dotenv import load_dotenv
from contextlib import asynccontextmanager
import pymongo
import numpy as np
import json
from pydantic import BaseModel

class Status(BaseModel):
    status: str

@asynccontextmanager
async def lifespan(app: FastAPI):
    MONGO_URL = os.environ.get('MONGO_URL')
    try:
        app.client = OpenAI()
        app.model = "gpt-3.5-turbo-0125"
        app.mongodb_client = pymongo.MongoClient(MONGO_URL, serverSelectionTimeoutMS = 1000)
        app.mongodb_client.server_info()
        print(f"MongoDB connected at {MONGO_URL}")
    except:
        raise Exception(f'Cannot connect to {MONGO_URL}')
    
    app.db = app.mongodb_client['db']
    app.db['user'].drop()
    app.db['user'].insert_one({
        "HP": 0,
        "ATK": 0,
        "MAXAMMO": 0,
        "RELTIME": 0
    })
    yield
    
    app.mongodb_client.close()
    
load_dotenv()
client = OpenAI()
app = FastAPI(lifespan=lifespan)


"""db types
    user: HP, previous stories, pictures, 
    monster: HP, ATK, MOVEMENT SPEED, ATK SPEED, NAME (generated by ChatGPT)
    """

@app.get('/')
async def main():
    return Response(content='<h1>This is a makentu server.</h1>', media_type='text/html')

@app.get('/create_story')
async def create_story(category: str = "å†’éšª", dest: str = "å°åŒ—"):
    # style, destination
    response = app.client.chat.completions.create(
        model=app.model,
        response_format={ "type": "json_object" },
        messages=[
            # {"role": "system", "content": "You are a helpful assistant."},
            {"role": "system", "content": "ä½ æ˜¯ä¸€ä½ç”Ÿæˆæ•…äº‹çš„å¾—åŠ›çš„åŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ä¸¦ä¸”å¦‚æœæœ‰JSONå›è¦†çš„æç¤ºï¼Œè«‹ä»¥JSONå›è¦†ã€‚"},
            # {"role": "user", "content": "Please create an RPG story and give four short choices of future outcomes."}
            {"role": "user", "content": f"è«‹å‰µé€ ä¸€å€‹ä¸»é¡Œç‚ºã€Œ{category}ã€ä¸¦ä¸”æ ¹æ“šç›®çš„åœ°ã€Œ{dest}ã€çš„é•·æƒ…ç¯€RPGæ•…äº‹(200å­—)ï¼Œ\
ä¸¦ä¸”ç”Ÿæˆ4ç¨®å¯èƒ½çš„æœªä¾†ç™¼å±•çš„é¸é …ã€‚é¸é …å­—æ•¸è«‹å°‘æ–¼10å€‹å­—ã€‚è«‹ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼ã€‚"}
        ]
    )
    
    app.db.chat_history.drop()
    app.db.chat_history.insert_many([
        {"role": "system", "content": "ä½ æ˜¯ä¸€ä½ç”Ÿæˆæ•…äº‹çš„å¾—åŠ›çš„åŠ©æ‰‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ä¸¦ä¸”å¦‚æœæœ‰JSONå›è¦†çš„æç¤ºï¼Œè«‹ä»¥JSONå›è¦†ã€‚"},
        {"role": "user", "content": f"è«‹å‰µé€ ä¸€å€‹ä¸»é¡Œç‚ºã€Œ{category}ã€ä¸¦ä¸”æ ¹æ“šç›®çš„åœ°ã€Œ{dest}ã€çš„é•·æƒ…ç¯€RPGæ•…äº‹(200å­—)ï¼Œ\
ä¸¦ä¸”ç”Ÿæˆ4ç¨®å¯èƒ½çš„æœªä¾†ç™¼å±•çš„é¸é …ã€‚é¸é …å­—æ•¸è«‹å°‘æ–¼10å€‹å­—ã€‚è«‹æ ¹æ“šç›®çš„åœ°è«‹ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼ã€‚"},
        {"role": "assistant", "content": response.choices[0].message.content}
    ])
    
    return Response(response.choices[0].message.content, headers={"Content-Type": "text/json;charset=UTF-8"})

@app.get('/story_response')
async def story_response(choice: str = '0'):
    chat_history = app.db.chat_history.find({}, {"_id": 0})
    # for chat in chat_history:
    #     print(chat)
    # print([*chat_history])
    # print(choice)
        
    # check whether game should be triggered
    if choice != '0':
        is_battle = ""
        i = 0
        response = None
        while 'æ˜¯' not in is_battle and 'å¦' not in is_battle and i < 5:
            response = app.client.chat.completions.create(
                model=app.model,
                messages=[
                    *chat_history,
                    {"role": "user", "content": f"æˆ‘é¸æ“‡ã€Œ{choice}ã€ã€‚è«‹å•é€™å€‹é¸é …æ˜¯å¦è¦è§¸ç™¼æˆ°é¬¥ï¼Ÿè«‹å›è¦†ã€Œæ˜¯ã€æˆ–ã€Œå¦ã€ã€‚"},
                ]
            )
            is_battle = response.choices[0].message.content
            i += 1
            
        app.db.chat_history.insert_many([
            {"role": "user", "content": f"æˆ‘é¸æ“‡ã€Œ{choice}ã€ã€‚æ ¹æ“šèªæ„ï¼Œè«‹å•é€™å€‹é¸é …æ˜¯å¦è¦è§¸ç™¼æˆ°é¬¥ï¼Ÿè«‹å›è¦†ã€Œæ˜¯ã€æˆ–ã€Œå¦ã€ã€‚"},
            {"role": "assistant", "content": is_battle},
        ])
        
        if 'æ˜¯' in is_battle:
            response = app.client.chat.completions.create(
                model=app.model,
                response_format={ "type": "json_object" },
                messages=[
                    *chat_history,
                    {"role": "user", "content": "è«‹æ ¹æ“šä»¥ä¸Šæ•…äº‹ç™¼å±•åŠæ‰€é¸çš„é¸é …ï¼Œç”Ÿæˆé—œæ–¼æˆ°é¬¥çš„æ•…äº‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œä¸¦ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼ï¼Œä¸¦ä¸”å°‡optionsè¨­æˆç©ºçš„é™£åˆ—ã€‚"},
                ]
            )
            app.db.chat_history.insert_many([
                {"role": "user", "content": "è«‹æ ¹æ“šä»¥ä¸Šæ•…äº‹ç™¼å±•åŠæ‰€é¸çš„é¸é …ï¼Œç”Ÿæˆé—œæ–¼æˆ°é¬¥çš„æ•…äº‹ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œä¸¦ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼ï¼Œä¸¦ä¸”å°‡optionsè¨­æˆç©ºçš„é™£åˆ—ã€‚"},
                {"role": "assistant", "content": response.choices[0].message.content},
            ])
            
            # generate monsters
            app.db.monsters.drop()
            app.db.status.drop()
            chat_history = app.db.chat_history.find({}, {"_id": 0})
            monster_response = app.client.chat.completions.create(
                model=app.model,
                response_format={ "type": "json_object" },
                messages=[
                    *chat_history,
                    {"role": "user", "content": "è«‹æ ¹æ“šä»¥ä¸Šæ•…äº‹ç™¼å±•åŠæ‰€é¸çš„é¸é …ï¼Œç”Ÿæˆé©ç•¶æ•¸é‡çš„å°æ€ªä»¥åŠé›¶æˆ–ä¸€éš»BOSSã€‚è«‹ç”Ÿæˆå„å€‹å°æ€ªä»¥åŠBOSSçš„åå­—(name)ã€\
è¡€é‡(HP)ã€æ”»æ“ŠåŠ›(ATK)ã€ç§»å‹•é€Ÿåº¦(MVSPD)ã€æ”»æ“Šé€Ÿåº¦(ATKSPD)ã€ä»¥åŠå‹æ…‹(TYPEï¼›0ä»£è¡¨å°æ€ªï¼Œ1ä»£è¡¨BOSS)ã€‚è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œä¸¦ä¸”æ¯éš»æ€ªç‰©ç”¨ä»¥ä¸Šè‹±æ–‡ç•¶ä½œJSONçš„éµå€¼ï¼Œ\
å›å‚³ä¸€å€‹listã€‚å¦‚æœæœ‰è«‹æŠŠBOSSçš„MVSPDè¨­å®šæˆ0"},
                ]
            )
            print(monster_response.choices[0].message.content)
            app.db.monsters.insert_many([*json.loads(monster_response.choices[0].message.content).values()])
            
        else:
            response = app.client.chat.completions.create(
                model=app.model,
                response_format={ "type": "json_object" },
                messages=[
                    *chat_history,
                    {"role": "user", "content": "è«‹æ ¹æ“šä»¥ä¸Šæ•…äº‹ç™¼å±•åŠæ‰€é¸çš„é¸é …ï¼Œç”Ÿæˆå¾ŒçºŒçš„æ•…äº‹(200å­—å…§)ä»¥åŠ4ç¨®å¯èƒ½çš„æœªä¾†ç™¼å±•çš„é¸é …ã€‚é¸é …å­—æ•¸è«‹å°‘æ–¼10å€‹å­—ã€‚\
è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œä¸¦ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼"},
                ]
            )
            app.db.chat_history.insert_many([
                {"role": "user", "content": "è«‹æ ¹æ“šä»¥ä¸Šæ•…äº‹ç™¼å±•åŠæ‰€é¸çš„é¸é …ï¼Œç”Ÿæˆå¾ŒçºŒçš„æ•…äº‹(200å­—å…§)ä»¥åŠ4ç¨®å¯èƒ½çš„æœªä¾†ç™¼å±•çš„é¸é …ã€‚é¸é …å­—æ•¸è«‹å°‘æ–¼10å€‹å­—ã€‚\
è«‹ç”¨ç¹é«”ä¸­æ–‡ï¼Œä¸¦ç”¨ã€Œstoryã€å’Œã€Œoptionsã€ç•¶ä½œJSONçš„éµå€¼"},
                {"role": "assistant", "content": response.choices[0].message.content},
            ])
        
        for x in app.db.chat_history.find({}, {"_id": 0}):
            print(x)
        return Response(response.choices[0].message.content, headers={"Content-Type": "text/json;charset=UTF-8"})

@app.get('/get_db')
async def get_db_data(db_name: str = 'chat_history'):
    data = app.db[db_name].find({}, {'_id': 0})
    return Response(json.dumps([*data], ensure_ascii=False), headers={"Content-Type": "text/json;charset=UTF-8"})

# @app.get('/get_db_one')
# async def get_db_data(db_name: str = 'chat_history'):
#     app.db[db_name].insert_one({
#         'status': 'win'
#     })
#     data = app.db[db_name].find_one({}, {'_id': 0})
    
#     print(data is not None)
#     return Response(json.dumps(data, ensure_ascii=False), headers={"Content-Type": "text/json;charset=UTF-8"})

@app.get('/clear_db')
async def clear_db_data(db_name: str = 'chat_history'):
    app.db[db_name].drop()
    return Response(f"Deleted {db_name} successfully")

@app.get('/get_user_info')
async def get_user_info():
    user = app.db.user.find({}, {"_id": 0})
    return Response(json.dumps([*user]), headers={"Content-Type": "text/json;charset=UTF-8"})

@app.get('/get_monsters_info')
async def insert_monster():
    monsters = app.db.monsters.find({}, {"_id": 0})
    return Response(json.dumps([*monsters]), headers={"Content-Type": "text/json;charset=UTF-8"})
    
# implement functions for user props update according to the choice of the user

@app.get("/game_is_ended")
async def game_is_ended():
    status = app.db.status.find_one({}, {'_id': 0})
    print(status)
    if status is not None:
        return Response(status['status'], headers={"Content-Type": "text/plain;charset=UTF-8"})
    else:
        return Response("playing")

@app.post("/game_ended")
async def game_ended(status:Status):
    if status.status.lower() == 'win' or status.status.lower() == 'lose':
        app.db.status.insert_one({
            'status': status.status.lower()
        })
        return Response("Status updated successfully", 200)
    else:
        return HTTPException(403, "Status is invalid")

# return a prompt for generating a picture based on the stories

if __name__ == "__main__":
    import uvicorn
    import argparse
    
    parser = argparse.ArgumentParser(description='Server settings')
    parser.add_argument("-H", "--host", help="host", type=str, default="localhost")
    parser.add_argument("-p", "--port", help="port", type=int, default="8000")
    args = parser.parse_args()
    # print(f"ğŸš€ğŸš€ Listening on http://{args.host}:{args.port}!!")
    
    uvicorn.run("server:app", host=args.host, port=args.port, reload=True)
    
